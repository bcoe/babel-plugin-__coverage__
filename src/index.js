'use strict'
// babel-plugin-__coverage__
//
// This is my first Babel plugin, and I wrote it during the night.
// Therefore, be prepared to see a lot of copypasta and wtf code.

import template from 'babel-template'
import nameFunction from 'babel-helper-function-name'
import { realpathSync } from 'fs'

const coverageTemplate = template(`
  var GLOBAL = (new Function('return this'))()
  var COVERAGE = GLOBAL['__coverage__'] || (GLOBAL['__coverage__'] = { })
  var FILE_COVERAGE = COVERAGE[PATH] || (COVERAGE[PATH] = GLOBAL['JSON'].parse(INITIAL))
`)

//
// Takes a relative path and returns a real path.
// Assumes the path name is relative to working directory.
//
function getRealpath (n) {
  try {
    return realpathSync(n) || n
  } catch (e) {
    return n
  }
}

module.exports = function ({ types: t }) {
  //
  // Return the immediate data structure local to a file.
  //
  function getData (context) {
    const path = getRealpath(context.file.opts.filename)
    //
    // XXX: Is it OK to mutate `context.file`? I don’t know but it works!
    //
    return context.file.__coverage__data || (context.file.__coverage__data = {
      //
      // Initial data that will be added in front of generated source code
      //
      base: {
        path: path,
        s: { },
        b: { },
        f: { },
        statementMap: { },
        fnMap: { },
        branchMap: { }
      },
      //
      // The counter that generates the next ID for each statement type.
      nextId: {
        s: 1,
        b: 1,
        f: 1
      }
    })
  }

  //
  // Turns a `SourceLocation` into a plain object.
  //
  function locToObject (loc) {
    return {
      start: {
        line: loc.start.line,
        column: loc.start.column
      },
      end: {
        line: loc.end.line,
        column: loc.end.column
      }
    }
  }

  //
  // Generates an AST representing an expression that will increment the
  // code coverage counter.
  //
  function increase (context, type, id, index) {
    const wrap = (index != null
      // If `index` present, turn `x` into `x[index]`.
      ? x => t.memberExpression(x, t.numericLiteral(index), true)
      : x => x
    )
    return t.unaryExpression('++',
      wrap(
        t.memberExpression(
          t.memberExpression(getData(context).id, t.identifier(type)),
          t.stringLiteral(id),
          true
        )
      )
    )
  }

  //
  // Adds coverage traking expression to a path.
  //
  // - If it’s a statement (`a`), turns into `++coverage; a`.
  // - If it’s an expression (`x`), turns into `(++coverage, x)`.
  //
  function instrument (path, increment) {
    if (path.isStatement()) {
      path.insertBefore(t.expressionStatement(increment))
    } else if (path.isExpression()) {
      path.replaceWith(t.sequenceExpression([ increment, path.node ]))
    } else {
      throw new Error(`wtf? I can’t cover a ${path.node.type}!!!!??`)
    }
  }

  //
  // Adds coverage to any statement.
  //
  function instrumentStatement (context, path) {
    const node = path.node
    if (!node) return

    // Don’t cover code generated by Babel.
    if (!node.loc) return

    // Make sure we don’t cover already instrumented code (only applies to statements).
    // XXX: Hacky node mutation again. PRs welcome!
    if (node.__coverage__instrumented) return
    node.__coverage__instrumented = true

    const id = nextStatementId(context, node.loc)
    instrument(path, increase(context, 's', id))
  }

  //
  // Returns the next statement ID.
  //
  function nextStatementId (context, loc) {
    const data = getData(context)
    const id = String(data.nextId.s++)
    data.base.s[id] = 0
    data.base.statementMap[id] = locToObject(loc)
    return id
  }

  //
  // Returns the next branch ID and adds the information to `branchMap` object.
  //
  function nextBranchId (context, line, type, locations) {
    const data = getData(context)
    const id = String(data.nextId.b++)
    data.base.b[id] = locations.map(() => 0)
    data.base.branchMap[id] = { line, type, locations: locations.map(locToObject) }
    return id
  }

  //
  // `a` => `++coverage; a` For most common type of statements.
  //
  function coverStatement (path) {
    instrumentStatement(this, path)
  }

  //
  // `var x = 1` => `var x = (++coverage, 1)`
  //
  function coverVariableDeclarator (path) {
    instrumentStatement(this, path.get('init'))
  }

  //
  // Adds branch coverage to `if` statements.
  //
  function coverIfStatement (path) {
    if (!path.node.loc) return
    instrumentStatement(this, path)
    if (!path.get('consequent').node) path.set('consequent', t.emptyStatement())
    if (!path.get('alternate').node) path.set('alternate', t.emptyStatement())
    const node = path.node
    const loc1 = node.consequent.loc || node.loc
    const loc2 = node.alternate.loc || loc1
    const id = nextBranchId(this, node.loc.start.line, 'if', [ loc1, loc2 ])
    instrument(path.get('consequent'), increase(this, 'b', id, 0))
    instrument(path.get('alternate'), increase(this, 'b', id, 1))
  }

  //
  // Adds branch coverage to `switch` statements.
  //
  function coverSwitchStatement (path) {
    if (!path.node.loc) return
    instrumentStatement(this, path)
    const validCases = path.get('cases').filter(p => p.node.loc)
    const id = nextBranchId(this, path.node.loc.start.line, 'switch', validCases.map(p => p.node.loc))
    let index = 0
    for (const p of validCases) {
      if (p.node.test) {
        instrumentStatement(this, p.get('test'))
      }
      p.node.consequent.unshift(increase(this, 'b', id, index++))
    }
  }

  //
  // `for (;; x)` => `for (;; ++coverage, x)`.
  // Because the increment may be stopped in the first iteration due to `break`.
  //
  function coverForStatement (path) {
    instrumentStatement(this, path)
    instrumentStatement(this, path.get('update'))
  }

  //
  // Covers a function.
  //
  function coverFunction (path) {
    if (!path.node.loc) return
    const node = path.node
    const data = getData(this)
    const id = String(data.nextId.f++)
    const nameOf = namedNode => namedNode && namedNode.id && namedNode.id.name || null
    data.base.f[id] = 0
    data.base.fnMap[id] = {
      name: nameOf(nameFunction(path)), // I love Babel!
      line: node.loc.start.line,
      loc: locToObject(node.loc)
    }
    const increment = increase(this, 'f', id)
    const body = path.get('body')
    if (body.isBlockStatement()) {
      body.node.body.unshift(t.expressionStatement(increment))
    } else if (body.isExpression()) {
      const sid = nextStatementId(this, body.node.loc || path.node.loc)
      body.replaceWith(t.sequenceExpression([
        increment,
        increase(this, 's', sid),
        body.node
      ]))
    } else {
      throw new Error(`wtf?? Can’t cover function with ${body.node.type}`)
    }
  }

  //
  // `a ? b : c` => `a ? (++coverage, b) : (++coverage, c)`.
  // Also adds branch coverage.
  //
  function coverConditionalExpression (path) {
    instrumentStatement(this, path.get('consequent'))
    instrumentStatement(this, path.get('alternate'))
    if (path.node.loc) {
      const node = path.node
      const loc1 = node.consequent.loc || node.loc
      const loc2 = node.alternate.loc || loc1
      const id = nextBranchId(this, node.loc.start.line, 'cond-expr', [ loc1, loc2 ])
      instrument(path.get('consequent'), increase(this, 'b', id, 0))
      instrument(path.get('alternate'), increase(this, 'b', id, 1))
    }
  }

  //
  // `a || b` => `a || (++coverage, b)`. Required due to short circuiting.
  // Also adds branch coverage.
  //
  function coverLogicalExpression (path) {
    instrumentStatement(this, path.get('right'))
    if (!path.node.loc) return
    const node = path.node
    const loc1 = node.left.loc || node.loc
    const loc2 = node.right.loc || loc1
    const id = nextBranchId(this, node.loc.start.line, 'binary-expr', [ loc1, loc2 ])
    instrument(path.get('left'), increase(this, 'b', id, 0))
    instrument(path.get('right'), increase(this, 'b', id, 1))
  }

  //
  // `(function (a = x) { })` => `(function (a = (++coverage, x)) { })`.
  // Because default may not be evaluated.
  //
  function coverAssignmentPattern (path) {
    instrumentStatement(this, path.get('right'))
  }

  return {
    visitor: {
      //
      // Shamelessly copied from istanbul.
      //
      ExpressionStatement: coverStatement,
      BreakStatement: coverStatement,
      ContinueStatement: coverStatement,
      DebuggerStatement: coverStatement,
      ReturnStatement: coverStatement,
      ThrowStatement: coverStatement,
      TryStatement: coverStatement,
      VariableDeclarator: coverVariableDeclarator,
      IfStatement: coverIfStatement,
      ForStatement: coverForStatement,
      ForInStatement: coverStatement,
      ForOfStatement: coverStatement,
      WhileStatement: coverStatement,
      DoWhileStatement: coverStatement,
      SwitchStatement: coverSwitchStatement,
      ArrowFunctionExpression: coverFunction,
      FunctionExpression: coverFunction,
      FunctionDeclaration: coverFunction,
      LabeledStatement: coverStatement,
      ConditionalExpression: coverConditionalExpression,
      LogicalExpression: coverLogicalExpression,
      AssignmentPattern: coverAssignmentPattern,

      Program: {
        enter (path) {
          // Save the variable name used for tracking coverage.
          getData(this).id = path.scope.generateUidIdentifier('__coverage__file')
        },
        exit (path) {
          // Prepends the coverage runtime.
          const realPath = getRealpath(this.file.opts.filename)
          path.node.body.unshift(...coverageTemplate({
            GLOBAL: path.scope.generateUidIdentifier('__coverage__global'),
            COVERAGE: path.scope.generateUidIdentifier('__coverage__object'),
            FILE_COVERAGE: getData(this).id,
            PATH: t.stringLiteral(realPath),
            INITIAL: t.stringLiteral(JSON.stringify(getData(this).base))
          }))
        }
      }
    }
  }
}
